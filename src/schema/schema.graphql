scalar DateTime

enum Sort {
  asc
  desc
}

input NameOrderByInput {
  name: Sort
}

input EventOrderByInput {
  name: Sort
  dateTime: Sort
}

type AuthPayload {
  token: String
  user: User
}

type Mutation {
  createEvent(name: String, maxAdmission: Int!, datetime: String): Event!
  signup(email: String!, password: String!, name: String!): AuthPayload
  login(email: String!, password: String!): AuthPayload
}

type Query {
  company(id: ID!): Company

  companies(skip: Int, take: Int, orderBy: NameOrderByInput): [Company!]

  eventsAfterDate(
    filter: String
    skip: Int
    take: Int
    orderBy: EventOrderByInput
  ): [Event!]!

  event(id: ID!): Event

  production(id: ID!): Production

  productions(
    filter: String
    skip: Int
    take: Int
    orderBy: NameOrderByInput
  ): [Production!]!
}

type User {
  id: ID!
  name: String!
  email: String!
}

type Company {
  id: ID!
  name: String!
  productions: [Production]
}

type Production {
  id: ID!
  name: String!
  producer: Producer
  events: [Event]
}

type Producer {
  id: ID!
  name: String!
  productions: [Production]
}

type Event {
  id: ID!
  name: String
  dateTime: DateTime
  maxAdmission: Int
  production: Production!
  venue: Venue
  seats: [Seat]
}

type Venue {
  id: ID!
  name: String!
  events: [Event]
}

# The seating chart is simply a template to populate a new event's seats
type SeatingChart {
  id: ID!
  name: String!
  venue: Venue!
  seats: [Seat]
}

# A Seat is unique to an Event
type Seat {
  id: ID!
  section: String!
  row: String!
  number: String!
  event: Event
  status: String!
}
